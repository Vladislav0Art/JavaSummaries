# Коллекции. Продолжение

## Реализации интерфейса `Set`

1. `HashSet<E>` - множество на основе хэша
1. `LinkedHashSet<E>` - множество на основе хэша с сохранением порядка обхода, порядок элементов ровно в порядке добавления.

Основной плюс второй в том, что обход делается быстрее.

Конструкторы:

1. `(Linked) HashSet<E>()` - пустое множество
1. `(Linked) HashSet<E>(Collection<?> c)` - элементы коллекции
1. `(Linked) HashSet<E>(int initialCapacity, double loadFactor)` - начальная вместимость и степень заполнения

## Вычисление хэшей

Нужен метод `Object.hashCode()`, должно выполняться:
- `hashCode()` не меняется, если не меняется объект
- Если объекты равны (т.е. `equals()`), то и хэши равны.

Правило: если перегрузили `equals()`, то нужно перегрузить и `hashCode()`. По дефолту `equals()` проверяет, что объекты лежат в одном месте в памяти, а `hashCode()` считает хэш от адреса в памяти, то есть одинаковые объекты, если не перегрузить, будут иметь разный хэш.

## `AbstractSet`

Абстрактный класс, позволяет быстро реализовать.

1. Неизменяемые множества
    - `iterator()`
    - `size()`

1. Изменяемые
    - `add(E o)`
    - `iterator.remove()`

## Списки

Это интерфейс `List<E> extends Collection<E>`, все элементы проиндексированы, поэтому итератор выдаёт элементы в определённой последовательности.

Помимо дефолтных операций, есть взятие вида:

`List<E> subList(int from, int to)` - важно помнить, что любые изменения, проведённые с саблистом, скажутся на обоих сущностях.

Также есть метод `listIteterator()`, который позволяет ходить в обе стороны

## Готовые реализации

1. `ArrayList<E>` - аналог вектора в плюсах

```java
                        
List<E> list = new ArrayList<>();
//                          ^^ 
// это даймонд оператор, работает, потому что на это место можно подставить только E


for (int i = list.size() - 1; i >= 0; i--) {
    System.out.println(list.get(i));
}
```

Почему это код плох? Потому что у каких-то реализаций списка метод `get()` может рабоать долго, а тут мы подразумеваем, что взятие по индексу работает за константу, но работаем-то мы через интерфейс `List<E>`.

Поэтому здесь нужно писать, что переменная лист - конкретно `ArrayList<E>`. 

2. `LinkedList<E>` - двусвязный список

Тоже есть абстрактный класс `AbstractList`, который позволяет реализовывать списки с произвольным доступом

1. Неизменяемые множества
    - `get(index)`
    - `size()`

1. Изменяемые
    - `set(index, element)`

1. Списки переменной длины
    - `add(index, element)`
    - `remove(index)`

Также есть `AbstractSequentialList` - списки с последовательным доступом.

## Очереди и деки

Очередь это интерфейс `Queue<E> extends Collection<E>`

Свойства очередей:
1. Порядок выдачи элементов определяется реализацией
1. Не могут хранить `null`
1. Может быть ограничен размер
1. Могут не принять элемент

Обычные методы `add(E o)`, `E element()` - вершина очереди и `E remove()` удалить элемент из вершины бросают исключения, а как мы знаем, исключения это долго. Поэтому есть [методы](https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html), не бросающие исключений (`offer(E o) == add(E o)`, `poll() == remove()`, `peek() == element()`). В случае ошибки они возвращают `null` (**rem**: `offer(E o)` вернет `false` в случае неудачи, остальные - `null`), и именно поэтому его нельзя хранить в очереди.

Реализации:

1. `LinkedList` - реализует ещё и интерфейс очереди.

Есть также класс `AbstarctQueue`, там мы реализуем методы, не бросающие исключений (`offer`, `poll`, `peek`). Почему? Потому что обернуть `offer`, `poll`, `peek` в функции, бросающие исключения, очень просто, в другую сторону - неэффективно, так как будет выбрасываться исключения, которые все равно будут проигнорированны (усложнять - легко, упрощать - сложно).

Интерфейс `Deque` реализует `LinkedList`, `ArrayDeque` - циклическая очередь

**Важно:** у `LinkedList` есть методы, который достались от списка, очереди и дека, так вот их смешивать совсем-совсем не стоит, а ещё лучше приводить к нужному интерфейсу и пользоваться нужными методами.

## Отображения

Интерфейс `Map<K, V>`, не наследуется от `Collection<E>`

Есть совершенно стандартные методы, а также взятия видов:

1. `Set<Map.Entry<K, V>> entrySet()` - множество пар. Тут `Map.Entry` - это один интерфейс внутри другого и задаёт эта штука пару.
1. `Collection<V> values()`
1. `Set<K> keySet()` - множество ключей, возвращаем `Set`, потому что ключи уникальны.

Массовые операции:

`putAll(Map<? extends K, ? extends V> map)` - добавление всех пар

Реализации `HashMap<K, V>` и `LinkedHashMap<K, V>`

Класс `AbstractMap` - нужно реализовать только метод `entrySet()`

## Упорядоченные коллекции

Как реализована возможность сравнения:

1. Интерфейс `Comparable<E>` - здесь `E` - тип, с которым разрешаем сравниваться
    - `int compareTo(E)`
1. Интерфейс `Comparator<E>`
    - `int compare(E, E)` - это внешний порядок сравнения

## Упорядоченные множества

Интерфейс `SortedSet<E>`

Реализует такой интерфейс 
`TreeSet<E>` - сбалансированное дерево поиска, в текущей реализации красно-черное дерево

Интерфейс `NavigableSet<E>` и его тоже реализует `TreeSet<E>`

Возникает вопрос, а почему `TreeSet<E>`, а не `TreeSet<E> extends Comparable<? super E>`. Дело в том, что мы можем передать внешний компаратор. Если же объект не реализует `Comparable` и мы не передали компаратор, то любая операция будет кидать исключение.

## Упорядоченные отображения

Интерфейс `SortedMap<K, V>` и `NavigableMap<K, V>`. Их реализует `TreeMap<K, V>`

## `PriorityQueue`

Очередь с приоритетом, реализована на основе двоичной кучи.

## Сортировки 

1. `sort(List<?> l)`
1. `sort(List<E> l, Comparator<? super E> c)`

## Оболочки коллекций

Если мы куда-то передаём коллекцию и не хотим, чтобы её там меняли - можно либо

1. Создавать каждый раз копию
1. Использовать оболочки `umodifiableSet(Set<E> s)`


# Здесь проходит граница летучек

## Внутренние и вложенные классы

Внутри классов тоже можно писать классы. Такие классы называются внутренними или вложенными

1. Классы с модификатором `static` называются вложенные (`Nested`) классы
1. Классы без модификатора `static` - внутренние (`Inner`)

Зачем вообще могут понадобиться такие классы? Например, если мы пишем коллекцию и там, разумеется, есть итератор, который должен иметь доступ к внутреннему состоянию коллекции. Как решить такую проблему?

- Сказать, что классы находятся в одном пакете и сделать данные в пакете `package-private` - это плохо, потому что непонятно кто вообще может находиться в одном пакете с нами
- Сделать данные публичными - ещё хуже
- Написать `Iterator` прямо внутри коллекции. Тогда у нас будет доступ к данным внешнего класса.

Мы говорили, что каждый класс компилируется в отдельный файл и здесь тоже так работает. При компиляции произойдёт следующее:

```java
class A {
    ...
    private class B {
        ...
    } 
}
```

У нас появится файлик `A.class` и `A.B.class`. Такое название нужно, чтобы понимать, что `B` написан внутри `A`.

Также, когда мы создаём экземпляр внутреннего класса - он привязывается к экземпляру внешнего класса (просто потому что мы пользуемся внутри полями внешнего класса - поэтому нужно знать к кому привязаны). Внутри внутреннего класса сохраняется ссылка на экземпляр внешнего класса, поэтому внешний класс живёт всегда дольше чем внутренний.

Если же нам не нужен доступ к содержимому внешнего класса, то наш выбор - вложенный (`Nested`) класс 

## Про модификаторы доступа у внутренних классов

```java
class A {
    public class B {
        ...
    }

    private class C {
        ...
    }
}
```

1. Модификатор `public` даёт нам возможность создать экземпляр **снаружи** внешнего класса
1. Модификатор `private` соответственно запрещает нам создать экземпляр снаружи

Но у нас всё ещё есть возможность сделать так:

```java
interface I {
    boolean end();

    void next();
}

class A {

    public I i() {
        return new Impl();
    }

    private class Impl implements I {
        ...
    }
}
```

То есть у нас есть публичный интерфейс, через который мы просто работаем. Именно так итераторы и реализовываются.

## Зачем нужны вложенные классы

- У нас всё ещё есть доступ к полям внешнего класса, поэтому если нам дадут экземпляр внешнего класса - сможем обращаться к приватным полям
- Ещё примеры в следующих сериях

## Локальные классы

```java

class A {
    ...

    public Selector selector() {
        return new SequenceSelector(); 
    }

    private class SequenceSelector implements Selector {
        ...
    }
}

```

Если метод `selector()` - единственное место, где нам нужен `SequenceSelector`, то можно сделать следующее:

```java
class A {
    ...

    public Selector selector2() {
        // Ниже - локальный класс
        class Selector2 implements Selector {
            ...
        }
        return new Selector2();
    }

    private class SequenceSelector implements Selector {
        ...
    }
}
```

Важно понимать, что локальный класс тоже внутренний или вложенный и зависит это от модификатора `static` метода, в котором мы создаём локальный класс

## Анонимные классы

Поймём что в примере выше нам вообще не важно какое у класса название и сделаем следующее:

```java
class A {
    ...

    public Selector selector3() {
        // ниже - анонимный класс, также является локальным
        // внутренний/вложенный также зависит от модификатора static метода
        // просто указали, что implements Selector
        return new Selector() {
            ...
        }
    }
}
```

У анонимного класса нет конструктора, вместо него может выступать секция инициализации.