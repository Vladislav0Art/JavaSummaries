# Коллекции. Продолжение

## Реализации интерфейса `Set`

1. `HashSet<E>` - множество на основе хэша
1. `LinkedHashSet<E>` - множество на основе хэша с сохранением порядка обхода, порядок элементов ровно в порядке добавления.

Основной плюс второй в том, что обход делается быстрее.

Конструкторы:

1. `(Linked) HashSet<E>()` - пустое множество
1. `(Linked) HashSet<E>(Collection<?> c)` - элементы коллекции
1. `(Linked) HashSet<E>(int initialCapacity, double loadFactor)` - начальная вместимость и степень заполнения

## Вычисление хэшей

Нужен метод `Object.hashCode()`, должно выполняться:
- `hashCode()` не меняется, если не меняется объект
- Если объекты равны (т.е. `equals()`), то и хэши равны.

Правило: если перегрузили `equals()`, то нужно перегрузить и `hashCode()`. По дефолту `equals()` проверяет, что объекты лежат в одном месте в памяти, а `hashCode()` считает хэш от адреса в памяти, то есть одинаковые объекты, если не перегрузить, будут иметь разный хэш.

## `AbstractSet`

Абстрактный класс, позволяет быстро реализовать.

1. Неизменяемые множества
    - `iterator()`
    - `size()`

1. Изменяемые
    - `add(E o)`
    - `iterator.remove()`

## Списки

Это интерфейс `List<E> extends Collection<E>`, все элементы проиндексированы, поэтому итератор выдаёт элементы в определённой последовательности.

Помимо дефолтных операций, есть взятие вида:

`List<E> subList(int from, int to)` - важно помнить, что любые изменения, проведённые с саблистом, скажутся на обоих сущностях.

Также есть метод `listIteterator()`, который позволяет ходить в обе стороны

## Готовые реализации

1. `ArrayList<E>` - аналог вектора в плюсах

```java
                        
List<E> list = new ArrayList<>();
//                          ^^ 
// это даймонд оператор, работает, потому что на это место можно подставить только E


for (int i = list.size() - 1; i >= 0; i--) {
    System.out.println(list.get(i));
}
```

Почему это код плох? Потому что у каких-то реализаций списка метод `get()` может рабоать долго, а тут мы подразумеваем, что взятие по индексу работает за константу, но работаем-то мы через интерфейс `List<E>`.

Поэтому здесь нужно писать, что переменная лист - конкретно `ArrayList<E>`. 

2. `LinkedList<E>` - двусвязный список

Тоже есть абстрактный класс `AbstractList`, который позволяет реализовывать списки с произвольным доступом

1. Неизменяемые множества
    - `get(index)`
    - `size()`

1. Изменяемые
    - `set(index, element)`

1. Списки переменной длины
    - `add(index, element)`
    - `remove(index)`

Также есть `AbstractSequentialList` - списки с последовательным доступом.

## Очереди и деки

Очередь это интерфейс `Queue<E> extends Collection<E>`

Свойства очередей:
1. Порядок выдачи элементов определяется реализацией
1. Не могут хранить `null`
1. Может быть ограничен размер
1. Могут не принять элемент

Обычные методы `add(E o)`, `E element()` - вершина очереди и `E remove()` удалить элемент из вершины бросают исключения, а как мы знаем, исключения это долго. Поэтому есть [методы](https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html), не бросающие исключений (`offer(E o) == add(E o)`, `poll() == remove()`, `peek() == element()`). В случае ошибки они возвращают `null` (**rem**: `offer(E o)` вернет `false` в случае неудачи, остальные - `null`), и именно поэтому его нельзя хранить в очереди.

Реализации:

1. `LinkedList` - реализует ещё и интерфейс очереди.

Есть также класс `AbstarctQueue`, там мы реализуем методы, не бросающие исключений (`offer`, `poll`, `peek`). Почему? Потому что обернуть `offer`, `poll`, `peek` в функции, бросающие исключения, очень просто, в другую сторону - неэффективно, так как будет выбрасываться исключения, которые все равно будут проигнорированны (усложнять - легко, упрощать - сложно).

Интерфейс `Deque` реализует `LinkedList`, `ArrayDeque` - циклическая очередь

**Важно:** у `LinkedList` есть методы, который достались от списка, очереди и дека, так вот их смешивать совсем-совсем не стоит, а ещё лучше приводить к нужному интерфейсу и пользоваться нужными методами.

## Отображения

Интерфейс `Map<K, V>`, не наследуется от `Collection<E>`

Есть совершенно стандартные методы, а также взятия видов:

1. `Set<Map.Entry<K, V>> entrySet()` - множество пар. Тут `Map.Entry` - это один интерфейс внутри другого и задаёт эта штука пару.
1. `Collection<V> values()`
1. `Set<K> keySet()` - множество ключей, возвращаем `Set`, потому что ключи уникальны.

Массовые операции:

`putAll(Map<? extends K, ? extends V> map)` - добавление всех пар

Реализации `HashMap<K, V>` и `LinkedHashMap<K, V>`

Класс `AbstractMap` - нужно реализовать только метод `entrySet()`

## Упорядоченные коллекции

Как реализована возможность сравнения:

1. Интерфейс `Comparable<E>` - здесь `E` - тип, с которым разрешаем сравниваться
    - `int compareTo(E)`
1. Интерфейс `Comparator<E>`
    - `int compare(E, E)` - это внешний порядок сравнения

## Упорядоченные множества

Интерфейс `SortedSet<E>`

Реализует такой интерфейс 
`TreeSet<E>` - сбалансированное дерево поиска, в текущей реализации красно-черное дерево

Интерфейс `NavigableSet<E>` и его тоже реализует `TreeSet<E>`

Возникает вопрос, а почему `TreeSet<E>`, а не `TreeSet<E> extends Comparable<? super E>`. Дело в том, что мы можем передать внешний компаратор. Если же объект не реализует `Comparable` и мы не передали компаратор, то любая операция будет кидать исключение.

## Упорядоченные отображения

Интерфейс `SortedMap<K, V>` и `NavigableMap<K, V>`. Их реализует `TreeMap<K, V>`

## `PriorityQueue`

Очередь с приоритетом, реализована на основе двоичной кучи.

## Сортировки 

1. `sort(List<?> l)`
1. `sort(List<E> l, Comparator<? super E> c)`

## Оболочки коллекций

Если мы куда-то передаём коллекцию и не хотим, чтобы её там меняли - можно либо

1. Создавать каждый раз копию
1. Использовать оболочки `umodifiableSet(Set<E> s)`
