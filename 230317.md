##  Внутренние и вложенные классы

```java
// Outer class
class A {

    B z1 = new B();
    B z2 = this.new B(); 
    // эти 2 строки эквивалентные, поэтому внутри класса при создании
    // экземпляра B к объекту A привяжемся автоматически


    int foo;
    /*
    1. Внутренние (Inner) классы
    2. Полное название A.B
    3. Внутри такого класса неявно хранится ссылка на экземпляр внешнего класса A.this
    4. Когда создаём переменную внутреннего класса - мы должны явно привязать его к экземпляру внешнего класса (A.B = a.new B())
    5. Нельзя заводить статические поля и статические методы (потому что можно написать во внешнем классе и будет такое же поведение, поэтому запретили)
    */
    class B {
        A.this.foo; 
        foo; // проверяем есть ли foo в локальном скоупе, если нет - то ищем как поле класса, потом во внешнем классе и так далее
    }




    /*
    1. Вложенные (Nested) классы. Например, в C++ есть только такие
    2. Полное название класса A.C, при компиляции A.C.class
    3. Тут ничего привязывать к внешнему классу не нужно
    4. Можно заводить статические поля и методы
    */
    static class C {
        // просто foo писать не можем, мы не привязаны к объекту
        // но если есть экземпляр A a
        // то писать a.foo можно, даже если foo был private
    }
}
```

Зачем такой механизм есть:
Внутренние классы:
1. Потому что в `Java` нет `friend`. Пример внутреннего класса - итератор.

Вложенные классы:
1. Причины писать вложенные класс - инкапсуляция кода (то есть если какой-то класс не нужен снаружи) и явная ассоциация с классом, например `Map.Entry`.
1. Например, мы хотим написать тесты, которые проверяют корректность приватных методов. Поэтому можно писать тесты как вложенные классы.

```java
class A {
    static class C {
        public static void main(String[] args) {
            A a = ...;
            // тут напишем тесты
        }
    }
}
```

У нас скомпилируется `A.class` и `A.C.class`, а потом, когда мы потестировали - можем выпилить `A.C.class` из сборки и никто и никогда не узнает, что у нас был такой вложенный класс

## Анонимные классы

Анонимный класс - когда внутри функции хотим его класс и создать его экземпляр.

- Ограничение таких классов в том, что мы можем реализовать только 1 интерфейс или отнаследоватся только от 1 класса. Они всё также могут быть внутренними/вложенными (зависит от наличия `static` у метода), поэтому ограничение, например, на создание статических методов все ещё есть

- У анонимных классов не может быть конструктора, его можно заменить секцией инициализации

- Компилируются такие классы в `A.$1.class`

```java
Shape x = new Shape() { // equiv to class ... extends/implements Shape
    int y = ...
    void foo() {
        ...
    }
    // это анонимный класс
    // Ограничение на 2 интерфейса потому, что иначе непонятно какой тип пишется слева
}
```

## Замыкание

Внутри анонимных классов мы можем использовать переменные:
- Переменные внутри класса
- Поля внешнего класса
- Локальные переменные

С первыми 2 пунктами проблем нет, поймём что за проблема с локальными переменными

```java
class A {
    private int z;

    Shape foo() {
        int i = 3;
        Shape x = new Shape() {
            // use i and z there
        };
        return x;
    }
}
```

`Shape` где-то создался и теперь, когда мы будем откуда-то снаружи вызывать какой-то метод, который использует внутри `i` и `z` происходит следующее.

1. `z` - обращаемся к полю внешнего класса, ничего страшного
2. `i` - она была создана на стеке, а значит её уже нет

Варианты решения:

1. Запретить!
2. Захватывать, то есть при копировать значение переменной к себе в объект, то есть при создании объекта скопируем текущее значение `i` и сохраним в виде невидимого поля

Поэтому выясняется следующее:

У анонимного класса на самом деле есть конструктор, который принимает:

1. Ссылку на экземпляр внешнего класса
1. Все захватываемые переменные (в нашем случае `i`)

Из-за того, что мы просто копируем проблема произойдёт, когда кто-то решит изменить переменную
`i`, поэтому копия не поменяется, а это не то, что мы ожидаем.

- Поэтому до `Java 8`, нужно было явно указать, что переменная `i` является `final` и только тогда мы могли захватывать её. 
- Начиная с `Java 8` можно не писать, `i` будет являться `effectively final`. Компилятор проверит, что мы её нигде не меняем.


```java
class A {
    private int z;

    void foo() {
        for (int i = 0; i < 10; i++) {
            int j = i; // без этого код не компилируется, потому что переменную i мы изменяем
            Shape x = new Shape() {
                System.out.println(i);
            };
        }
        return;
    }
}
```

```java
class A {
    private int z;

    void foo(int k) {
        Shape x = new Shape() {
            // раньше не могли захватывать k, потому что она не final
            // дописать final в общем случае не можем, потому что метод мог достаться 
            // от интерфейса
        };
        return;
    }
}
```

## Некоторые примеры

Тут было несколько примеров, демонстрирующих что-то из вышенаписанного, можно посмотреть на записи, таймкод `0:58:54`

Из интересного - пример красивой реализации `Singleton`

```java
public class Example {
    private Example() {}

    private static class SignetonHolder {
        public static Example instance = new Example();
    }

    public static Example getInstance() {
        return SingletonHolder.instance;
    }
}
```

В чём плюс такой реализации? Статическая инициализация класса `SingletonHolder` начнётся только тогда, когды мы вызовём метод `getInstance()`. То есть объект `Example` будет создан только тогда, когда он нам понадобится.

Ещё интересная идея:

```java
public interface Node {
    public Node getNext();

    public static final Node NULL = new Node() {
        public Node getNext() {
            return Node.NULL;
        }
    }
}
```

Ну и собственно говоря, тесты:

```java
public class Test {
    int i = 4;

    private void foo() {
        System.out.pritln("foo() in Test");
    }

    private void bar() {
        System.out.pritln("bar() in Test");
    }

    public static class Test3 {
        public static void main(String[] args) {
            Test t = new Test();
            t.foo();
            t.bar();
        }
    }
}
```

## Симуляция множественного наследования

Хотим отнаследовать класс `C` от классов `A` и `B`

```java
class A {
    int x;
}

class B {
    int y;
}

class C {
    int z;
    CA ca = new CA();
    CB cb = new CB();

    private class CA extends A {
        void foo() {
            // здесь видим x, но не видим y
            // но можем достать y через cb.getY(), ведь поля внешнего класса мы видим
        }

        public getX() {
            ...
        }
    }

    private class CB extends B {
        void foo() {
            // здесь видим y, но не видим x
            // аналогично здесь достаём x через ca.getX()
        }

        public getY() {
            ...
        }
    }

    A getA() {
        return ca;
    }
}
```

Это нам позволяет, например, отнаследоваться *трижды* от класса `A`, но с разными реализациями!

