##  Внутренние и вложенные классы

```java
// Outer class
class A {

    B z1 = new B();
    B z2 = this.new B(); 
    // эти 2 строки эквивалентные, поэтому внутри класса при создании
    // экземпляра B к объекту A привяжемся автоматически


    int foo;
    /*
    1. Внутренние (Inner) классы
    2. Полное название A.B
    3. Внутри такого класса неявно хранится ссылка на экземпляр внешнего класса A.this
    4. Когда создаём переменную внутреннего класса - мы должны явно привязать его к экземпляру внешнего класса (A.B = a.new B())
    5. Нельзя заводить статические поля и статические методы (потому что можно написать во внешнем классе и будет такое же поведение, поэтому запретили)
    */
    class B {
        A.this.foo; 
        foo; // проверяем есть ли foo в локальном скоупе, если нет - то ищем как поле класса, потом во внешнем классе и так далее
    }




    /*
    1. Вложенные (Nested) классы. Например, в C++ есть только такие
    2. Полное название класса A.C, при компиляции A.C.class
    3. Тут ничего привязывать к внешнему классу не нужно
    4. Можно заводить статические поля и методы
    */
    static class C {
        // просто foo писать не можем, мы не привязаны к объекту
        // но если есть экземпляр A a
        // то писать a.foo можно, даже если foo был private
    }
}
```

Зачем такой механизм есть:
Внутренние классы:
1. Потому что в `Java` нет `friend`. Пример внутреннего класса - итератор.

Вложенные классы:
1. Причины писать вложенные класс - инкапсуляция кода (то есть если какой-то класс не нужен снаружи) и явная ассоциация с классом, например `Map.Entry`.
1. Например, мы хотим написать тесты, которые проверяют корректность приватных методов. Поэтому можно писать тесты как вложенные классы.

```java
class A {
    static class C {
        public static void main(String[] args) {
            A a = ...;
            // тут напишем тесты
        }
    }
}
```

У нас скомпилируется `A.class` и `A.C.class`, а потом, когда мы потестировали - можем выпилить `A.C.class` из сборки и никто и никогда не узнает, что у нас был такой вложенный класс

## Анонимные классы

Анонимный класс - когда внутри функции хотим его класс и создать его экземпляр.

- Ограничение таких классов в том, что мы можем реализовать только 1 интерфейс или отнаследоватся только от 1 класса. Они всё также могут быть внутренними/вложенными (зависит от наличия `static` у метода), поэтому ограничение, например, на создание статических методов все ещё есть

- У анонимных классов не может быть конструктора, его можно заменить секцией инициализации

- Компилируются такие классы в `A.$1.class`

```java
Shape x = new Shape() { // equiv to class ... extends/implements Shape
    int y = ...
    void foo() {
        ...
    }
    // это анонимный класс
    // Ограничение на 2 интерфейса потому, что иначе непонятно какой тип пишется слева
}
```

## Замыкание

Внутри анонимных классов мы можем использовать переменные:
- Переменные внутри класса
- Поля внешнего класса
- Локальные переменные

С первыми 2 пунктами проблем нет, поймём что за проблема с локальными переменными

```java
class A {
    private int z;

    Shape foo() {
        int i = 3;
        Shape x = new Shape() {
            // use i and z there
        };
        return x;
    }
}
```

`Shape` где-то создался и теперь, когда мы будем откуда-то снаружи вызывать какой-то метод, который использует внутри `i` и `z` происходит следующее.

1. `z` - обращаемся к полю внешнего класса, ничего страшного
2. `i` - она была создана на стеке, а значит её уже нет

Варианты решения:

1. Запретить!
2. Захватывать, то есть при копировать значение переменной к себе в объект, то есть при создании объекта скопируем текущее значение `i` и сохраним в виде невидимого поля

Поэтому выясняется следующее:

У анонимного класса на самом деле есть конструктор, который принимает:

1. Ссылку на экземпляр внешнего класса
1. Все захватываемые переменные (в нашем случае `i`)

Из-за того, что мы просто копируем ...