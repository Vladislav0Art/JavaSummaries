# Java

## Витруальная машина и байткод 

- Подход `C/C++`:
    - Исходный код -> машинный код -> процессор
    

- Подход `Java`
    - Исходный код -> компилятор ->  байткод виртуальной машины -> виртуальная машина -> процессор

**Зачем это всё** 

- Кроссплатформенность. То есть программа, которую мы написали работает одинаково под разными платформами (в отличии от `C/C++`). Это как раз и обеспечивает виртуальная машина.

## Как быстро работает виртуальная машина.

- `Just in Time` компиляция позволяет делать оптимизации в runtime, потому что мы знаем значения переменных и т.д. 

```c++
// Just-In-Time компиляция позволит сомтимизировать это просто до y += n, если, например x <= 0.
for (int i = 0; i < n; i++) {
    if (x > 0) {
        ...
    }
    else {
        y += 1;
    }
}
```

- В результате `Java 7` всего в 1.5-2 раза медленнее `C`, а на некоторых тестах даже быстрее.

## Зачем ещё нужна виртуальная машина

1. Память 
    - Подход `C/C++`:
    - Выделил память -> поработал -> почистил память.

    - Подход `Java`
        - Выделил память -> поработал -> забыл

    Как найти объекты, до которых не можем добраться:
    - Запускаем `dfs` со стеков и статической памяти - то, до чего не можем добраться  - можно чистить.
    - Помимо этого считаем ссылки на объекты. 

2. Безопасность
    - Верификация байткода
    - Автоматическое управление памятью
        - нет арифметики указателей
        - невозможно испортить память

3. Заложена отличная многопоточность

## Всякие мелочи

- `JRE (Java Runtime Environment)` - нужна для запуска уже скомпилированных программ

- `JDK (Java Development Kit)` - инструменты разработчика(компилятор), включает в себя `JRE`

- На `Java` виртуальной машине можно запускать программы на любом языке, который компилирует в байт-код `JVM`. 
    - `Groovy`
    - `Kotlin`
    - `Scala`
    - `Jython`

### Реализации Java

- `Oracle Java`
- `Open JDK`
- много много ещё


