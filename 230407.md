# Лямбды

До `Java 8` мы жили так:

```java
Collections.sort(new Comparator<String>() {
    public int Compare() {
        //
    }
})
```

А в `Java 8` появились лямбды!

```java
Collections.sort(list, (a, b) -> b.compareTo(a));
```

Изначально это был просто синтаксический сахар уже в `Java 7`. Но это работало бесконечно долго, потому что каждый анонимный класс компилируется в отдельный файл. И уже в `Java 8` всё переписали.

## Интерфейсы

- В `Java 8` в интерфейсах разрешили писать реализации

- Разрешили писать `default` реализации, то есть если у класса нет реализации метода, то будет взята дефолтная реализация
    - Не доступно для `equals()`, `hashCode()`, `toString()`. Почему нельзя - обоснование ниже

```java
interface F {
    default equals()
}

class X implements F {
    // но тут не появится метод equals(), потому что есть неявное наследование от Object и возьмём метод оттуда
}
```

```java
interface Foo {
    default int f(int x) { return x + 42 }

}

interface Bar {
    default int f(int x) { return x * x }
    
}

class FooBar implements Foo, Bar { } // Fail, непонятно что вызывать. Надо явно указывать
// Но если у нас наследование и реализация интерфейса и там одинаковые методы - вызовем метод класса
```

## Функциональные интерфейсы

1. Интерфейсы, у которых ровно 1 абстрактный метод
1. Опционально можно добавить аннотация `@FunctionalInterface` - заставляем компилятор проверить, что является таковым

Примеры:
1. Компаратор
1. `Function<T, R>`
1. `BiFunction<T, U, R>`
1. `Consumer<T>`

## Лямбды

1. Новый компактный синтаксис для функциональных интерфейсов. Но ведёт себя так, как будто мы создали экземпляр анонимного класса. Хранятся вместе с классом, где их используем. Чтобы поддержать это - в `JVM` добавили `invoke dymanic`
1. Компилятор сам выводит типы

```java
List<User> users = getAllUSers()
Collections.sort(users, (u1, u2) -> 
    u1.getName().compareTo(u2.getName()));
```

## Применение лямбд

1. `list.forEach(u -> ...)` - принимает на вход `Consumer`. То есть над каждым объектом есть возможность совершить какое-то действие
1. `users.removeIf(u -> ...)`

То, что лямбды не являются анонимными классами - даёт нам право делать так:

```java
Function<String, Integer> f1 = Integer::parseInt
// ~ x -> Integer.parseInt()
```

У лямбды нет типа, он обретается тогда, когда мы её куда-то подставляем

Ограничения лямбд:

1. Не можем захватывать не `final` переменные
1. Не умеем бросать исключение
1. Лямбда - не класс

У лямбды нет никакого состояния, ровно 1 метод, нет секции инициализации.

## `java.util.collection`

Класс `Optional<T>` - контейнер на 1 элемент, который может быть пустой или не пустой.

Операции:
1. `get()` - то, что лежит или исключение
1. `isPresent()`

## `java.util.stream`

```java
collection.stream()
    .filter(s -> s.endsWith("s"))
    .mapToInt(String::length)
    .max()

parallelStream() // обрабатывается на разных ядрах, чтобы это реализовать существует splitIterator
```

Работает, начиная с конца, сначала вызывается `max()`, он просит у прошлой команды в цепочке один элемент и так далее. Потом `max()` доставляют элемент и он просит новый. 

Это классы `Stream, IntStream, ...`. `IntStream` - стрим для примитивных типов

Это поток элементов, обрабатываемый оптом
- Может не хранить элементы
- Может быть ленивым
- Может быть бесконечным

Операции над потоками:
1. Промежуточные
    - Порождают поток
    - Ленивые

1. Завершающие
    - Порождают значения
    - Жадные

Терминальная операция выковыривают из стрима данные, если её нет - не будет сделано вообще ни одного действия
